<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fourier Transforms · FFTW.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FFTW.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li class="current"><a class="toctext" href="fft.html">Fourier Transforms</a><ul class="internal"></ul></li><li><a class="toctext" href="dsp.html">Signal Processing</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="fft.html">Fourier Transforms</a></li></ul><a class="edit-page" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/docs/src/fft.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Fourier Transforms</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Fourier-Transforms-1" href="#Fourier-Transforms-1">Fourier Transforms</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.fft" href="#FFTW.fft"><code>FFTW.fft</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fft(A [, dims])</code></pre><p>Performs a multidimensional FFT of the array <code>A</code>. The optional <code>dims</code> argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along. Most efficient if the size of <code>A</code> along the transformed dimensions is a product of small primes; see <code>nextprod()</code>. See also <code>plan_fft()</code> for even greater efficiency.</p><p>A one-dimensional FFT computes the one-dimensional discrete Fourier transform (DFT) as defined by</p><div>\[\operatorname{DFT}(A)[k] =
  \sum_{n=1}^{\operatorname{length}(A)}
  \exp\left(-i\frac{2\pi
  (n-1)(k-1)}{\operatorname{length}(A)} \right) A[n].\]</div><p>A multidimensional FFT simply performs this operation along each transformed dimension of <code>A</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><ul><li><p>Julia starts FFTW up with 1 thread by default. Higher performance is usually possible by increasing number of threads. Use <code>FFTW.set_num_threads(Sys.CPU_CORES)</code> to use as many threads as cores on your system.</p></li><li><p>This performs a multidimensional FFT by default. FFT libraries in other languages such as Python and Octave perform a one-dimensional FFT along the first non-singleton dimension of the array. This is worth noting while performing comparisons. For more details, refer to the <a href="@ref">Noteworthy Differences from other Languages</a> section of the manual.</p></li></ul></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dft.jl#L399-L429">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.fft!" href="#FFTW.fft!"><code>FFTW.fft!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fft!(A [, dims])</code></pre><p>Same as <a href="fft.html#FFTW.fft"><code>fft</code></a>, but operates in-place on <code>A</code>, which must be an array of complex floating-point numbers.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dft.jl#L167-L172">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.ifft" href="#FFTW.ifft"><code>FFTW.ifft</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ifft(A [, dims])</code></pre><p>Multidimensional inverse FFT.</p><p>A one-dimensional inverse FFT computes</p><div>\[\operatorname{IDFT}(A)[k] = \frac{1}{\operatorname{length}(A)}
\sum_{n=1}^{\operatorname{length}(A)} \exp\left(+i\frac{2\pi (n-1)(k-1)}
{\operatorname{length}(A)} \right) A[n].\]</div><p>A multidimensional inverse FFT simply performs this operation along each transformed dimension of <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dft.jl#L150-L164">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.ifft!" href="#FFTW.ifft!"><code>FFTW.ifft!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ifft!(A [, dims])</code></pre><p>Same as <a href="fft.html#FFTW.ifft"><code>ifft</code></a>, but operates in-place on <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dft.jl#L143-L147">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.bfft" href="#FFTW.bfft"><code>FFTW.bfft</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bfft(A [, dims])</code></pre><p>Similar to <a href="fft.html#FFTW.ifft"><code>ifft</code></a>, but computes an unnormalized inverse (backward) transform, which must be divided by the product of the sizes of the transformed dimensions in order to obtain the inverse. (This is slightly more efficient than <a href="fft.html#FFTW.ifft"><code>ifft</code></a> because it omits a scaling step, which in some applications can be combined with other computational steps elsewhere.)</p><div>\[\operatorname{BDFT}(A)[k] = \operatorname{length}(A) \operatorname{IDFT}(A)[k]\]</div></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dft.jl#L175-L187">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.bfft!" href="#FFTW.bfft!"><code>FFTW.bfft!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bfft!(A [, dims])</code></pre><p>Same as <a href="fft.html#FFTW.bfft"><code>bfft</code></a>, but operates in-place on <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dft.jl#L190-L194">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.plan_fft" href="#FFTW.plan_fft"><code>FFTW.plan_fft</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">plan_fft(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)</code></pre><p>Pre-plan an optimized FFT along given dimensions (<code>dims</code>) of arrays matching the shape and type of <code>A</code>.  (The first two arguments have the same meaning as for <a href="fft.html#FFTW.fft"><code>fft</code></a>.) Returns an object <code>P</code> which represents the linear operator computed by the FFT, and which contains all of the information needed to compute <code>fft(A, dims)</code> quickly.</p><p>To apply <code>P</code> to an array <code>A</code>, use <code>P * A</code>; in general, the syntax for applying plans is much like that of matrices.  (A plan can only be applied to arrays of the same size as the <code>A</code> for which the plan was created.)  You can also apply a plan with a preallocated output array <code>Â</code> by calling <code>A_mul_B!(Â, plan, A)</code>.  (For <code>A_mul_B!</code>, however, the input array <code>A</code> must be a complex floating-point array like the output <code>Â</code>.) You can compute the inverse-transform plan by <code>inv(P)</code> and apply the inverse plan with <code>P \ Â</code> (the inverse plan is cached and reused for subsequent calls to <code>inv</code> or <code>\</code>), and apply the inverse plan to a pre-allocated output array <code>A</code> with <code>A_ldiv_B!(A, P, Â)</code>.</p><p>The <code>flags</code> argument is a bitwise-or of FFTW planner flags, defaulting to <code>FFTW.ESTIMATE</code>. e.g. passing <code>FFTW.MEASURE</code> or <code>FFTW.PATIENT</code> will instead spend several seconds (or more) benchmarking different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags.  The optional <code>timelimit</code> argument specifies a rough upper bound on the allowed planning time, in seconds. Passing <code>FFTW.MEASURE</code> or <code>FFTW.PATIENT</code> may cause the input array <code>A</code> to be overwritten with zeros during plan creation.</p><p><a href="fft.html#FFTW.plan_fft!"><code>plan_fft!</code></a> is the same as <a href="fft.html#FFTW.plan_fft"><code>plan_fft</code></a> but creates a plan that operates in-place on its argument (which must be an array of complex floating-point numbers). <a href="fft.html#FFTW.plan_ifft"><code>plan_ifft</code></a> and so on are similar but produce plans that perform the equivalent of the inverse transforms <a href="fft.html#FFTW.ifft"><code>ifft</code></a> and so on.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dft.jl#L90-L119">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.plan_ifft" href="#FFTW.plan_ifft"><code>FFTW.plan_ifft</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">plan_ifft(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)</code></pre><p>Same as <a href="fft.html#FFTW.plan_fft"><code>plan_fft</code></a>, but produces a plan that performs inverse transforms <a href="fft.html#FFTW.ifft"><code>ifft</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dft.jl#L60-L65">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.plan_bfft" href="#FFTW.plan_bfft"><code>FFTW.plan_bfft</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">plan_bfft(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)</code></pre><p>Same as <a href="fft.html#FFTW.plan_fft"><code>plan_fft</code></a>, but produces a plan that performs an unnormalized backwards transform <a href="fft.html#FFTW.bfft"><code>bfft</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dft.jl#L82-L87">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.plan_fft!" href="#FFTW.plan_fft!"><code>FFTW.plan_fft!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">plan_fft!(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)</code></pre><p>Same as <a href="fft.html#FFTW.plan_fft"><code>plan_fft</code></a>, but operates in-place on <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dft.jl#L122-L126">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.plan_ifft!" href="#FFTW.plan_ifft!"><code>FFTW.plan_ifft!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">plan_ifft!(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)</code></pre><p>Same as <a href="fft.html#FFTW.plan_ifft"><code>plan_ifft</code></a>, but operates in-place on <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dft.jl#L68-L72">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.plan_bfft!" href="#FFTW.plan_bfft!"><code>FFTW.plan_bfft!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">plan_bfft!(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)</code></pre><p>Same as <a href="fft.html#FFTW.plan_bfft"><code>plan_bfft</code></a>, but operates in-place on <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dft.jl#L75-L79">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.rfft" href="#FFTW.rfft"><code>FFTW.rfft</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rfft(A [, dims])</code></pre><p>Multidimensional FFT of a real array <code>A</code>, exploiting the fact that the transform has conjugate symmetry in order to save roughly half the computational time and storage costs compared with <a href="fft.html#FFTW.fft"><code>fft</code></a>. If <code>A</code> has size <code>(n_1, ..., n_d)</code>, the result has size <code>(div(n_1,2)+1, ..., n_d)</code>.</p><p>The optional <code>dims</code> argument specifies an iterable subset of one or more dimensions of <code>A</code> to transform, similar to <a href="fft.html#FFTW.fft"><code>fft</code></a>. Instead of (roughly) halving the first dimension of <code>A</code> in the result, the <code>dims[1]</code> dimension is (roughly) halved in the same way.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dft.jl#L129-L140">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.irfft" href="#FFTW.irfft"><code>FFTW.irfft</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">irfft(A, d [, dims])</code></pre><p>Inverse of <a href="fft.html#FFTW.rfft"><code>rfft</code></a>: for a complex array <code>A</code>, gives the corresponding real array whose FFT yields <code>A</code> in the first half. As for <a href="fft.html#FFTW.rfft"><code>rfft</code></a>, <code>dims</code> is an optional subset of dimensions to transform, defaulting to <code>1:ndims(A)</code>.</p><p><code>d</code> is the length of the transformed real array along the <code>dims[1]</code> dimension, which must satisfy <code>div(d,2)+1 == size(A,dims[1])</code>. (This parameter cannot be inferred from <code>size(A)</code> since both <code>2*size(A,dims[1])-2</code> as well as <code>2*size(A,dims[1])-1</code> are valid sizes for the transformed real array.)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dft.jl#L300-L311">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.brfft" href="#FFTW.brfft"><code>FFTW.brfft</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">brfft(A, d [, dims])</code></pre><p>Similar to <a href="fft.html#FFTW.irfft"><code>irfft</code></a> but computes an unnormalized inverse transform (similar to <a href="fft.html#FFTW.bfft"><code>bfft</code></a>), which must be divided by the product of the sizes of the transformed dimensions (of the real output array) in order to obtain the inverse transform.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dft.jl#L314-L320">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.plan_rfft" href="#FFTW.plan_rfft"><code>FFTW.plan_rfft</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">plan_rfft(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)</code></pre><p>Pre-plan an optimized real-input FFT, similar to <a href="fft.html#FFTW.plan_fft"><code>plan_fft</code></a> except for <a href="fft.html#FFTW.rfft"><code>rfft</code></a> instead of <a href="fft.html#FFTW.fft"><code>fft</code></a>. The first two arguments, and the size of the transformed result, are the same as for <a href="fft.html#FFTW.rfft"><code>rfft</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dft.jl#L432-L438">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.plan_brfft" href="#FFTW.plan_brfft"><code>FFTW.plan_brfft</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">plan_brfft(A, d [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)</code></pre><p>Pre-plan an optimized real-input unnormalized transform, similar to <a href="fft.html#FFTW.plan_rfft"><code>plan_rfft</code></a> except for <a href="fft.html#FFTW.brfft"><code>brfft</code></a> instead of <a href="fft.html#FFTW.rfft"><code>rfft</code></a>. The first two arguments and the size of the transformed result, are the same as for <a href="fft.html#FFTW.brfft"><code>brfft</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dft.jl#L441-L448">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.plan_irfft" href="#FFTW.plan_irfft"><code>FFTW.plan_irfft</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">plan_irfft(A, d [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)</code></pre><p>Pre-plan an optimized inverse real-input FFT, similar to <a href="fft.html#FFTW.plan_rfft"><code>plan_rfft</code></a> except for <a href="fft.html#FFTW.irfft"><code>irfft</code></a> and <a href="fft.html#FFTW.brfft"><code>brfft</code></a>, respectively. The first three arguments have the same meaning as for <a href="fft.html#FFTW.irfft"><code>irfft</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dft.jl#L342-L348">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.dct" href="#FFTW.dct"><code>FFTW.dct</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dct(A [, dims])</code></pre><p>Performs a multidimensional type-II discrete cosine transform (DCT) of the array <code>A</code>, using the unitary normalization of the DCT. The optional <code>dims</code> argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along.  Most efficient if the size of <code>A</code> along the transformed dimensions is a product of small primes; see <a href="@ref"><code>nextprod</code></a>. See also <a href="fft.html#FFTW.plan_dct"><code>plan_dct</code></a> for even greater efficiency.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dct.jl#L41-L50">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.dct!" href="#FFTW.dct!"><code>FFTW.dct!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dct!(A [, dims])</code></pre><p>Same as <a href="fft.html#FFTW.dct!"><code>dct!</code></a>, except that it operates in-place on <code>A</code>, which must be an array of real or complex floating-point values.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dct.jl#L65-L70">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.idct" href="#FFTW.idct"><code>FFTW.idct</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">idct(A [, dims])</code></pre><p>Computes the multidimensional inverse discrete cosine transform (DCT) of the array <code>A</code> (technically, a type-III DCT with the unitary normalization). The optional <code>dims</code> argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along.  Most efficient if the size of <code>A</code> along the transformed dimensions is a product of small primes; see <a href="@ref"><code>nextprod</code></a>.  See also <a href="fft.html#FFTW.plan_idct"><code>plan_idct</code></a> for even greater efficiency.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dct.jl#L53-L62">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.idct!" href="#FFTW.idct!"><code>FFTW.idct!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">idct!(A [, dims])</code></pre><p>Same as <a href="fft.html#FFTW.idct!"><code>idct!</code></a>, but operates in-place on <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dct.jl#L73-L77">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.plan_dct" href="#FFTW.plan_dct"><code>FFTW.plan_dct</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">plan_dct(A [, dims [, flags [, timelimit]]])</code></pre><p>Pre-plan an optimized discrete cosine transform (DCT), similar to <a href="fft.html#FFTW.plan_fft"><code>plan_fft</code></a> except producing a function that computes <a href="fft.html#FFTW.dct"><code>dct</code></a>. The first two arguments have the same meaning as for <a href="fft.html#FFTW.dct"><code>dct</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dct.jl#L24-L31">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.plan_dct!" href="#FFTW.plan_dct!"><code>FFTW.plan_dct!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">plan_dct!(A [, dims [, flags [, timelimit]]])</code></pre><p>Same as <a href="fft.html#FFTW.plan_dct"><code>plan_dct</code></a>, but operates in-place on <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dct.jl#L7-L11">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.plan_idct" href="#FFTW.plan_idct"><code>FFTW.plan_idct</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">plan_idct(A [, dims [, flags [, timelimit]]])</code></pre><p>Pre-plan an optimized inverse discrete cosine transform (DCT), similar to <a href="fft.html#FFTW.plan_fft"><code>plan_fft</code></a> except producing a function that computes <a href="fft.html#FFTW.idct"><code>idct</code></a>. The first two arguments have the same meaning as for <a href="fft.html#FFTW.idct"><code>idct</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dct.jl#L14-L21">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.plan_idct!" href="#FFTW.plan_idct!"><code>FFTW.plan_idct!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">plan_idct!(A [, dims [, flags [, timelimit]]])</code></pre><p>Same as <a href="fft.html#FFTW.plan_idct"><code>plan_idct</code></a>, but operates in-place on <code>A</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dct.jl#L34-L38">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.fftshift-Tuple{Any}" href="#FFTW.fftshift-Tuple{Any}"><code>FFTW.fftshift</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">fftshift(x)</code></pre><p>Swap the first and second halves of each dimension of <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dft.jl#L357-L361">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.fftshift-Tuple{Any,Any}" href="#FFTW.fftshift-Tuple{Any,Any}"><code>FFTW.fftshift</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">fftshift(x,dim)</code></pre><p>Swap the first and second halves of the given dimension or iterable of dimensions of array <code>x</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dft.jl#L372-L376">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.ifftshift" href="#FFTW.ifftshift"><code>FFTW.ifftshift</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ifftshift(x, [dim])</code></pre><p>Undoes the effect of <code>fftshift</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/dft.jl#L381-L385">source</a><br/></section><p>The following functions are not exported from the package and thus must be qualified with the <code>FFTW.</code> prefix on use.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.r2r" href="#FFTW.r2r"><code>FFTW.r2r</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">r2r(A, kind [, dims])</code></pre><p>Performs a multidimensional real-input/real-output (r2r) transform of type <code>kind</code> of the array <code>A</code>, as defined in the FFTW manual. <code>kind</code> specifies either a discrete cosine transform of various types (<code>FFTW.REDFT00</code>, <code>FFTW.REDFT01</code>, <code>FFTW.REDFT10</code>, or <code>FFTW.REDFT11</code>), a discrete sine transform of various types (<code>FFTW.RODFT00</code>, <code>FFTW.RODFT01</code>, <code>FFTW.RODFT10</code>, or <code>FFTW.RODFT11</code>), a real-input DFT with halfcomplex-format output (<code>FFTW.R2HC</code> and its inverse <code>FFTW.HC2R</code>), or a discrete Hartley transform (<code>FFTW.DHT</code>).  The <code>kind</code> argument may be an array or tuple in order to specify different transform types along the different dimensions of <code>A</code>; <code>kind[end]</code> is used for any unspecified dimensions.  See the FFTW manual for precise definitions of these transform types, at http://www.fftw.org/doc.</p><p>The optional <code>dims</code> argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along. <code>kind[i]</code> is then the transform type for <code>dims[i]</code>, with <code>kind[end]</code> being used for <code>i &gt; length(kind)</code>.</p><p>See also <a href="fft.html#FFTW.plan_r2r"><code>plan_r2r</code></a> to pre-plan optimized r2r transforms.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/fft.jl#L5-L28">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.r2r!" href="#FFTW.r2r!"><code>FFTW.r2r!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">r2r!(A, kind [, dims])</code></pre><p>Same as <a href="fft.html#FFTW.r2r"><code>r2r</code></a>, but operates in-place on <code>A</code>, which must be an array of real or complex floating-point numbers.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/fft.jl#L31-L36">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.plan_r2r" href="#FFTW.plan_r2r"><code>FFTW.plan_r2r</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">plan_r2r(A, kind [, dims [, flags [, timelimit]]])</code></pre><p>Pre-plan an optimized r2r transform, similar to <a href="fft.html#FFTW.plan_fft"><code>plan_fft</code></a> except that the transforms (and the first three arguments) correspond to <a href="fft.html#FFTW.r2r"><code>r2r</code></a> and <a href="fft.html#FFTW.r2r!"><code>r2r!</code></a>, respectively.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/fft.jl#L46-L52">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FFTW.plan_r2r!" href="#FFTW.plan_r2r!"><code>FFTW.plan_r2r!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">plan_r2r!(A, kind [, dims [, flags [, timelimit]]])</code></pre><p>Similar to <a href="fft.html#FFTW.plan_fft"><code>plan_fft</code></a>, but corresponds to <a href="fft.html#FFTW.r2r!"><code>r2r!</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaMath/FFTW.jl/tree/f73dec9345b40b471e75f8d4fce4403de90cb7fb/src/fft.jl#L39-L43">source</a><br/></section><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="dsp.html"><span class="direction">Next</span><span class="title">Signal Processing</span></a></footer></article></body></html>
